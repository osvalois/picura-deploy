name: Kubernetes Resource Management

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0'  # Ejecutar cada domingo a medianoche
  workflow_dispatch:  # Permite la ejecuciÃ³n manual

jobs:
  manage-kubernetes-resources:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Set up kubectl
      uses: azure/setup-kubectl@v1

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig.yaml
        chmod 600 kubeconfig.yaml
        export KUBECONFIG=$(pwd)/kubeconfig.yaml
        kubectl config view --raw
        kubectl config current-context
        kubectl cluster-info

    - name: Debug - Print kubeconfig
      run: |
        echo "Content of kubeconfig:"
        cat kubeconfig.yaml

    - name: Debug - Check kubectl config
      run: |
        echo "Current context:"
        kubectl config current-context
        echo "Available contexts:"
        kubectl config get-contexts
        echo "Clusters:"
        kubectl config get-clusters

    - name: Debug - Test connection
      run: |
        echo "Attempting to list nodes:"
        kubectl get nodes
        echo "Attempting to get cluster info:"
        kubectl cluster-info

    - name: Debug - Check kubectl version
      run: kubectl version --client

    - name: Debug - Check environment
      run: |
        echo "KUBECONFIG: $KUBECONFIG"
        echo "PWD: $(pwd)"
        ls -la

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: 'latest'

    - name: Install or update Monitoring resources
      run: make install-monitoring
      continue-on-error: true

    - name: Install or update Logging resources
      run: make install-logging
      continue-on-error: true

    - name: Install or update Resource Management
      run: make install-resource-management
      continue-on-error: true

    - name: Apply Resource Quotas
      run: make apply-resource-quotas
      continue-on-error: true

    - name: Apply Limit Ranges
      run: make apply-limit-ranges
      continue-on-error: true

    - name: Install or update HPA
      run: make install-hpa
      continue-on-error: true

    - name: Install or update VPA
      run: make install-vpa
      continue-on-error: true

    - name: Update all Helm charts
      run: make update-charts
      continue-on-error: true

    - name: Expose services
      run: make expose-services
      continue-on-error: true

    - name: Get and display public service URLs
      id: get_urls
      run: |
        echo "Waiting for Load Balancers to be assigned public IPs..."
        sleep 60  # Esperar un minuto para que se asignen las IPs

        PROMETHEUS_IP=$(kubectl get svc prometheus-kube-prometheus-prometheus -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        GRAFANA_IP=$(kubectl get svc prometheus-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        ELASTICSEARCH_IP=$(kubectl get svc elasticsearch-master -n logging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        KIBANA_IP=$(kubectl get svc kibana-kibana -n logging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        METRICS_SERVER_IP=$(kubectl get svc metrics-server -n kube-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

        echo "Public URLs:"
        echo "Prometheus: http://$PROMETHEUS_IP:9090"
        echo "Grafana: http://$GRAFANA_IP:80"
        echo "Elasticsearch: http://$ELASTICSEARCH_IP:9200"
        echo "Kibana: http://$KIBANA_IP:5601"
        echo "Metrics Server API: https://$METRICS_SERVER_IP:443/apis/metrics.k8s.io/v1beta1/"

        echo "prometheus_url=http://$PROMETHEUS_IP:9090" >> $GITHUB_OUTPUT
        echo "grafana_url=http://$GRAFANA_IP:80" >> $GITHUB_OUTPUT
        echo "elasticsearch_url=http://$ELASTICSEARCH_IP:9200" >> $GITHUB_OUTPUT
        echo "kibana_url=http://$KIBANA_IP:5601" >> $GITHUB_OUTPUT
        echo "metrics_server_url=https://$METRICS_SERVER_IP:443/apis/metrics.k8s.io/v1beta1/" >> $GITHUB_OUTPUT

    - name: Create Release Notes
      run: |
        cat << EOF > release_notes.md
        # Service URLs

        ## Monitoring
        - Prometheus: ${{ steps.get_urls.outputs.prometheus_url }}
        - Grafana: ${{ steps.get_urls.outputs.grafana_url }}

        ## Logging
        - Elasticsearch: ${{ steps.get_urls.outputs.elasticsearch_url }}
        - Kibana: ${{ steps.get_urls.outputs.kibana_url }}

        ## Resource Management
        - Metrics Server API: ${{ steps.get_urls.outputs.metrics_server_url }}

        Please note that you may need to use appropriate authentication to access these services.
        EOF
        cat release_notes.md

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Service URLs ${{ github.run_number }}
        body_path: release_notes.md
        draft: false
        prerelease: false

    - name: Show resource usage
      run: |
        kubectl top nodes
        kubectl top pods --all-namespaces

    - name: Clean up kubeconfig
      run: rm kubeconfig.yaml
      if: always()
      
      